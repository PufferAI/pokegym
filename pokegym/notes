# ##################################################################################################################
#                                            # Imports because syntax
# ##################################################################################################################

import csv
from pdb import set_trace as T
import uuid
from gymnasium import Env, spaces
import numpy as np
from collections import defaultdict
import io, os
import random
from pathlib import Path
import mediapy as media


from pokegym.pyboy_binding import (ACTIONS, make_env, open_state_file,
    load_pyboy_state, run_action_on_emulator)
from pokegym import ram_map, game_map, data
from environment import Base

# ##################################################################################################################
#                                            # this is env_logging:
# ##################################################################################################################


    with open("experiments/current_exp.txt", "r") as file:
      exp_name = file.read()
    self.exp_path = Path(f'experiments/{str(exp_name)}')
    self.s_path = Path(f'{str(self.exp_path)}/sessions/{str(self.env_id)}')
    self.env_id = str(uuid.uuid4())[:4]

  def write_to_log(self):
        pokemon_info = data.pokemon_l(self.game)
        x, y ,map_n = ram_map.position(self.game)
        session_path = self.s_path
        base_dir = self.exp_path
        reset = self.reset_count
        env_id = self.env_id
        csv_file_path = base_dir / "unique_positions.csv"
        base_dir.mkdir(parents=True, exist_ok=True)
        session_path.mkdir(parents=True, exist_ok=True)
        with open(session_path / self.full_name_log, 'w') as f:
            for pokemon in pokemon_info:
                f.write(f"Slot: {pokemon['slot']}\n")
                f.write(f"Name: {pokemon['name']}\n")
                f.write(f"Level: {pokemon['level']}\n")
                f.write(f"Moves: {', '.join(pokemon['moves'])}\n")
                f.write("\n")  # Add a newline between Pokémon
        with open(csv_file_path, 'a') as csv_file:
            csv_writer = csv.writer(csv_file)
            csv_writer.writerow([env_id, reset, x, y, map_n])

    exp_path = Path(f'current_exp').with_suffix('.txt')
    with open(data.config.data_dir / exp_path, 'w') as file:
        file.write(f"{data.exp_name}")

        
# ##################################################################################################################
#                                            # Useful functions
# ##################################################################################################################

    STATE_PATH = __file__.rstrip("environment.py") + "States"

    def get_random_state():
        state_files = [f for f in os.listdir(STATE_PATH) if f.endswith(".state")]
        if not state_files:
            raise FileNotFoundError("No State files found in the specified directory.")
        return random.choice(state_files)

    state_file = get_random_state()
    randstate = os.path.join(STATE_PATH, state_file)

# ##################################################################################################################
#                                           # TODO Pull Functions from this
# ##################################################################################################################
    class Environment(Base):
        def __init__(
            self,
            rom_path="pokemon_red.gb",
            state_path=None,
            headless=True,
            save_video=True,
            quiet=False,
            verbose=False,
            **kwargs,
        ):
            super().__init__(rom_path, state_path, headless, save_video, quiet, **kwargs)
            self.counts_map = np.zeros((444, 436))
            self.verbose = verbose
            self.screenshot_counter = 0
            self.include_conditions = []
            self.seen_maps_difference = set()
            self.seen_maps = 0
            self.current_maps = []
            self.exclude_map_n = {37, 38, 39, 43, 52, 53, 55, 57}
            self.exclude_map_n = set()
            # self.exclude_map_n_moon = {0, 1, 2, 12, 13, 14, 15, 33, 34, 37, 38, 39, 40, 41, 42, 43, 44, 47, 50, 51, 52, 53, 54, 55, 56, 57, 58, 193, 68}
            self.is_dead = False
            self.talk_to_npc_reward = 0
            self.talk_to_npc_count = {}
            self.already_got_npc_reward = set()
            self.ss_anne_state = False
            self.seen_npcs = set()
            self.explore_npc_weight = 1
            self.last_map = -1
            self.init_hidden_obj_mem()
            self.seen_pokemon = np.zeros(152, dtype=np.uint8)
            self.caught_pokemon = np.zeros(152, dtype=np.uint8)
            self.moves_obtained = np.zeros(0xA5, dtype=np.uint8)
            self.log = True
            
        def update_pokedex(self):
            for i in range(0xD30A - 0xD2F7):
                caught_mem = self.game.get_memory_value(i + 0xD2F7)
                seen_mem = self.game.get_memory_value(i + 0xD30A)
                for j in range(8):
                    self.caught_pokemon[8*i + j] = 1 if caught_mem & (1 << j) else 0
                    self.seen_pokemon[8*i + j] = 1 if seen_mem & (1 << j) else 0   
        
        def update_moves_obtained(self):
            # Scan party
            for i in [0xD16B, 0xD197, 0xD1C3, 0xD1EF, 0xD21B, 0xD247]:
                if self.game.get_memory_value(i) != 0:
                    for j in range(4):
                        move_id = self.game.get_memory_value(i + j + 8)
                        if move_id != 0:
                            if move_id != 0:
                                self.moves_obtained[move_id] = 1
            # Scan current box (since the box doesn't auto increment in pokemon red)
            num_moves = 4
            box_struct_length = 25 * num_moves * 2
            for i in range(self.game.get_memory_value(0xda80)):
                offset = i*box_struct_length + 0xda96
                if self.game.get_memory_value(offset) != 0:
                    for j in range(4):
                        move_id = self.game.get_memory_value(offset + j + 8)
                        if move_id != 0:
                            self.moves_obtained[move_id] = 1
        
        def get_items_in_bag(self, one_indexed=0):
            first_item = 0xD31E
            # total 20 items
            # item1, quantity1, item2, quantity2, ...
            item_ids = []
            for i in range(0, 20, 2):
                item_id = self.game.get_memory_value(first_item + i)
                if item_id == 0 or item_id == 0xff:
                    break
                item_ids.append(item_id + one_indexed)
            return item_ids
        
        def get_hm_rewards(self):
            hm_ids = [0xC4, 0xC5, 0xC6, 0xC7, 0xC8]
            items = self.get_items_in_bag()
            total_hm_cnt = 0
            for hm_id in hm_ids:
                if hm_id in items:
                    total_hm_cnt += 1
            return total_hm_cnt * 1
                
        def update_heat_map(self, r, c, current_map):
            '''
            Updates the heat map based on the agent's current position.

            Args:
                r (int): global y coordinate of the agent's position.
                c (int): global x coordinate of the agent's position.
                current_map (int): ID of the current map (map_n)

            Updates the counts_map to track the frequency of visits to each position on the map.
            '''
            # Convert local position to global position
            try:
                glob_r, glob_c = game_map.local_to_global(r, c, current_map)
            except IndexError:
                print(f'IndexError: index {glob_r} or {glob_c} for {current_map} is out of bounds for axis 0 with size 444.')
                glob_r = 0
                glob_c = 0

            # Update heat map based on current map
            if self.last_map == current_map or self.last_map == -1:
                # Increment count for current global position
                    try:
                        self.counts_map[glob_r, glob_c] += 1
                    except:
                        pass
            else:
                # Reset count for current global position if it's a new map for warp artifacts
                self.counts_map[(glob_r, glob_c)] = -1

            # Update last_map for the next iteration
            self.last_map = current_map

        def find_neighboring_npc(self, npc_bank, npc_id, player_direction, player_x, player_y) -> int:

            npc_y = ram_map.npc_y(self.game, npc_id, npc_bank)
            npc_x = ram_map.npc_x(self.game, npc_id, npc_bank)
            if (
                (player_direction == 0 and npc_x == player_x and npc_y > player_y) or
                (player_direction == 4 and npc_x == player_x and npc_y < player_y) or
                (player_direction == 8 and npc_y == player_y and npc_x < player_x) or
                (player_direction == 0xC and npc_y == player_y and npc_x > player_x)
            ):
                # Manhattan distance
                return abs(npc_y - player_y) + abs(npc_x - player_x)

            return 1000
            
        def step(self, action, fast_video=True):
            run_action_on_emulator(
                self.game,
                self.screen,
                ACTIONS[action],
                self.headless,
                fast_video=fast_video,
            )
            self.time += 1
            if self.save_video:
                self.add_video_frame()
            
            # Exploration reward
            r, c, map_n = ram_map.position(self.game)
                    # Convert local position to global position
            try:
                glob_r, glob_c = game_map.local_to_global(r, c, map_n)
            except IndexError:
                print(f'IndexError: index {glob_r} or {glob_c} is out of bounds for axis 0 with size 444.')
                glob_r = 0
                glob_c = 0
            
            # Only reward for specified coordinates, not all coordinates seen
            if self.rewardable_coords(glob_c, glob_r):
                self.seen_coords.add((r, c, map_n))
            else:
                self.seen_coords_no_reward.add((glob_c, glob_r, map_n))

            if map_n != self.prev_map_n:
                self.prev_map_n = map_n
                if map_n not in self.seen_maps:
                    self.seen_maps.add(map_n)
                    self.talk_to_npc_count[map_n] = 0  # Initialize NPC talk count for this new map
                    self.save_state()
        
            self.update_pokedex()
            self.update_moves_obtained()

            exploration_reward = 0.01 * len(self.seen_coords)
            self.update_heat_map(r, c, map_n)

            # Level reward
            party_size, party_levels = ram_map.party(self.game)
            self.max_level_sum = max(self.max_level_sum, sum(party_levels))
            if self.max_level_sum < 30:
                level_reward = 1 * self.max_level_sum
            else:
                level_reward = 30 + (self.max_level_sum - 30) / 4
                
            # Healing and death rewards
            hp = ram_map.hp(self.game)
            hp_delta = hp - self.last_hp
            party_size_constant = party_size == self.last_party_size

            # Only reward if not reviving at pokecenter
            if hp_delta > 0 and party_size_constant and not self.is_dead:
                self.total_healing += hp_delta

            # Dead if hp is zero
            if hp <= 0 and self.last_hp > 0:
                self.death_count += 1
                self.is_dead = True
            elif hp > 0.01:  # TODO: Check if this matters
                self.is_dead = False

            # Update last known values for next iteration
            self.last_hp = hp
            self.last_party_size = party_size
            death_reward = 0 # -0.08 * self.death_count  # -0.05
            
            # Set rewards
            healing_reward = self.total_healing

            # Opponent level reward
            max_opponent_level = max(ram_map.opponent(self.game))
            self.max_opponent_level = max(self.max_opponent_level, max_opponent_level)
            opponent_level_reward = 0 # 0.2 * self.max_opponent_level

            # Badge reward
            badges = ram_map.badges(self.game)
            badges_reward = 5 * badges
                    
            # Save Bill
            bill_state = ram_map.saved_bill(self.game)
            bill_reward = 10 * bill_state
            
            # SS Anne appeared
            ss_anne_state = ram_map.ss_anne_appeared(self.game)
            if ss_anne_state:
                ss_anne_state_reward = 10 # 5
                ss_anne_obtained = 1
            else:
                ss_anne_state_reward = 0
                ss_anne_obtained = 0
        
            # HM reward
            hm_count = self.get_hm_rewards()
            hm_reward = hm_count * 10 # 5

            # Event reward
            events = ram_map.events(self.game)
            self.max_events = max(self.max_events, events)
            event_reward = self.max_events

            money = ram_map.money(self.game)
            
            # Explore NPCs
                    # check if the font is loaded
            if ram_map.mem_val(self.game, 0xCFC4):
                # check if we are talking to a hidden object:
                if ram_map.mem_val(self.game, 0xCD3D) == 0x0 and ram_map.mem_val(self.game, 0xCD3E) == 0x0:
                    # add hidden object to seen hidden objects
                    self.seen_hidden_objs.add((ram_map.mem_val(self.game, 0xD35E), ram_map.mem_val(self.game, 0xCD3F)))
                else:
                    # check if we are talking to someone
                    # if ram_map.if_font_is_loaded(self.game):
                        # get information for player
                    player_direction = ram_map.player_direction(self.game)
                    player_y = ram_map.player_y(self.game)
                    player_x = ram_map.player_x(self.game)
                    # get the npc who is closest to the player and facing them
                    # we go through all npcs because there are npcs like
                    # nurse joy who can be across a desk and still talk to you
                    mindex = (0, 0)
                    minv = 1000
                    for npc_bank in range(1):
                        
                        for npc_id in range(1, ram_map.sprites(self.game) + 15):
                            npc_dist = self.find_neighboring_npc(npc_bank, npc_id, player_direction, player_x, player_y)
                            if npc_dist < minv:
                                mindex = (npc_bank, npc_id)
                                minv = npc_dist        
                    self.seen_npcs.add((ram_map.map_n(self.game), mindex[0], mindex[1]))

            explore_npcs_reward = self.reward_scale * self.explore_npc_weight * len(self.seen_npcs) * 0.00015
            seen_pokemon_reward = self.reward_scale * sum(self.seen_pokemon) * 0.00010
            caught_pokemon_reward = self.reward_scale * sum(self.caught_pokemon) * 0.00010
            moves_obtained_reward = self.reward_scale * sum(self.moves_obtained) * 0.00010
            explore_hidden_objs_reward = self.reward_scale * self.explore_hidden_obj_weight * len(self.seen_hidden_objs) * 0.00015

            reward = self.reward_scale * (
                event_reward
                + explore_npcs_reward # Doesn't reset on reset but maybe should?
                + seen_pokemon_reward
                + caught_pokemon_reward
                + moves_obtained_reward
                + explore_hidden_objs_reward # Resets on reset
                + bill_reward
                + hm_reward
                + level_reward
                + opponent_level_reward
                + death_reward # Resets on reset
                + badges_reward
                + healing_reward # Resets each step
                + exploration_reward # Resets on reset
            )

            # Subtract previous reward
            # TODO: Don't record large cumulative rewards in the first place
            if self.last_reward is None:
                reward = 0
                self.last_reward = 0
            else:
                nxt_reward = reward
                reward -= self.last_reward
                self.last_reward = nxt_reward

            info = {}
            done = self.time >= self.max_episode_steps
            if self.save_video and done:
                self.full_frame_writer.close()
            if done:
                info = {
                    "reward": {
                        "delta": reward,
                        "event": event_reward,
                        "level": level_reward,
                        "opponent_level": opponent_level_reward,
                        "death": death_reward,
                        "badges": badges_reward,
                        "bill_saved_reward": bill_reward,
                        "hm_count_reward": hm_reward,
                        "ss_anne_done_reward": ss_anne_state_reward,
                        "healing": healing_reward,
                        "exploration": exploration_reward,
                        "explore_npcs_reward": explore_npcs_reward,
                        "seen_pokemon_reward": seen_pokemon_reward,
                        "caught_pokemon_reward": caught_pokemon_reward,
                        "moves_obtained_reward": moves_obtained_reward,
                        "hidden_obj_count_reward": explore_hidden_objs_reward,
                    },
                    "maps_explored": len(self.seen_maps),
                    "party_size": party_size,
                    "highest_pokemon_level": max(party_levels),
                    "total_party_level": sum(party_levels),
                    "deaths": self.death_count,
                    "bill_saved": bill_state,
                    "hm_count": hm_count,
                    "ss_anne_obtained": ss_anne_obtained,
                    "badge_1": float(badges >= 1),
                    "badge_2": float(badges >= 2),
                    "event": events,
                    "money": money,
                    "pokemon_exploration_map": self.counts_map,
                    "seen_npcs_count": len(self.seen_npcs),
                    "seen_pokemon": sum(self.seen_pokemon),
                    "caught_pokemon": sum(self.caught_pokemon),
                    "moves_obtained": sum(self.moves_obtained),
                    "hidden_obj_count": len(self.seen_hidden_objs),
                }

            if self.verbose:
                print(
                    f'number of signs: {ram_map.signs(self.game)}, number of sprites: {ram_map.sprites(self.game)}\n',
                    f"steps: {self.time}\n",
                    f"seen_npcs #: {len(self.seen_npcs)}\n",
                    f"seen_npcs set: {self.seen_npcs}\n",
                    # f"is_in_battle: {ram_map.is_in_battle(self.game)}",
                    f"exploration reward: {exploration_reward}\n",
                    f"explore_npcs reward: {explore_npcs_reward}\n",
                    f"level_Reward: {level_reward}\n",
                    f"healing: {healing_reward}\n",
                    f"death: {death_reward}\n",
                    f"op_level: {opponent_level_reward}\n",
                    f"badges reward: {badges_reward}\n",
                    f"event reward: {event_reward}\n",
                    f"money: {money}\n",
                    f"ai reward: {reward}\n",
                    f"Info: {info}\n",
                )
            
            return self.render(), reward, done, done, info

# ##################################################################################################################
#                                           # Battle Functions
# ##################################################################################################################
    
    self.ap_party_level = 0  # The sum of player (agent) Pokémon levels in the party
    self.wp_party_level = 0  # The sum of enemy (wild) Pokémon levels in the party
    self.ap_level = 0  # The level of the player (agent) Pokémon in the lead position
    self.wp_level = 0  # The level of the enemy (wild) Pokémon in the lead position
    self.ap_party_size = 0  # The battle_reward test initialize variable current player (agent) party size
    # (how many Pokémon in party)
    self.wp_party_size = 0  # The battle_reward test initialize variable current enemy (wild) party size
    # (how many Pokémon in party)
    self.ap_health = self.get_ap_health_sum()  # The sum of player (agent) Pokémon health in the party
    self.wp_health = 0  # The sum of enemy (wild) Pokémon health in the party
    self.in_battle = 0  # Flag of current battle state (-1 white-out, 0 normal, 1 wild, 2 trainer)
    self.battle_rewarded = False  # Was a reward given from last battle?
    self.battle_reward_value = 0  # points rewarded from last battle
    self.total_battle_reward = 0  # total points rewarded
    self.levels_satisfied = False

    def get_ap_level_sum(self):
        sum_levels = sum(self.read_m(a) for a in [0xD18C, 0xD1B8, 0xD1E4, 0xD210, 0xD23C, 0xD268])
        if sum_levels < 0:
            return 1
        else:
            return sum_levels

    def get_wp_level_sum(self):
        sum_levels = sum(self.read_m(a) for a in [0xCFF3, 0xD8F1, 0xD91D, 0xD949, 0xD975, 0xD9A1])
        if sum_levels < 0:
            return 1
        else:
            return sum_levels

    def read_low_high(self, low_adder, high_adder):
        low = self.read_m(low_adder)
        high = self.read_m(high_adder)
        return low + high

    def get_ap_health_sum(self):
        # HP addresses for each Pokémon in the party
        hp_addresses = [
            (0xD015, 0xD016),  # Pokemon 1
            (0xD198, 0xD199),  # Pokemon 2
            (0xD1C4, 0xD1C5),  # Pokemon 3
            (0xD1F0, 0xD1F1),  # Pokemon 4
            (0xD21C, 0xD21D),  # Pokemon 5
            (0xD248, 0xD249),  # Pokemon 6
        ]

        sum_hp = 0

        # Iterate through each pair of addresses and sum the HP values
        for low_adder, high_adder in hp_addresses:
            sum_hp += self.read_low_high(low_adder, high_adder)

        return sum_hp

    def get_wp_health_sum(self):
        # HP addresses for each Pokémon in the party
        hp_addresses = [
            (0xD8A5, 0xCFE7),  # Pokemon 1
            (0xD8D1, 0xD8D2),  # Pokemon 2
            (0xD8FD, 0xD8FE),  # Pokemon 3
            (0xD929, 0xD92A),  # Pokemon 4
            (0xD955, 0xD956),  # Pokemon 5
            (0xD981, 0xD982),  # Pokemon 6
        ]

        sum_hp = 0

        # Iterate through each pair of addresses and sum the HP values
        for low_adder, high_adder in hp_addresses:
            sum_hp += self.read_low_high(low_adder, high_adder)

        return sum_hp

    def update_battle_values(self):
        self.ap_party_size = self.read_m(0xD163)
        self.wp_party_size = self.read_m(0xD89C)
        self.ap_health = self.get_ap_health_sum()
        self.wp_health = self.get_wp_health_sum()
        self.ap_party_level = self.get_ap_level_sum()
        self.wp_party_level = self.get_wp_level_sum()
        self.ap_level = self.read_m(0xCD0F)
        self.wp_level = self.read_m(0xCD23)
        self.in_battle = self.read_m(0xD057)

        print(
            f"Update Battle values Function\n"
            f"Battle Flag: {self.in_battle}\n"
            f"Last Battle Rewarded: {self.battle_rewarded}\n"
            f"Level Difference: {self.ap_level - self.wp_level}\n"
            f"Reward: {self.battle_reward_value}\n\n"
        )

    def has_battle_been_won(self):

        is_in_battle = self.in_battle >= 1

        fled = self.read_m(0xD078)  # needed for console only
        pokeball_catch = self.read_m(0xD11C)  # needed for console only

        if is_in_battle:
            enemy_party_hp = self.get_wp_health_sum()

            if enemy_party_hp <= 0 and self.in_battle != -1:
                return True

            # Required to print to Console only
            if self.in_battle == -1 or fled != 0 or pokeball_catch != 0:  # whiteout, run/flee, capture
                self.battle_rewarded = False
                self.battle_reward_value = 0
                return False
        else:
            return False

    def calculate_battle_reward(self):
        # ap = Agent Party, wp = Wild Pokémon
        if not self.has_battle_been_won():
            return 0

        bonus = 0  # Resets  bonus for calculation

        trainer_battle = self.in_battle == 2

        # Calculate level difference for wild battles
        if not trainer_battle:
            level_difference = self.ap_level - self.wp_level
        else:
            ap_avg_level = self.ap_party_level / self.ap_party_size  # if self.ap_party_size > 0 else 0
            wp_avg_level = self.wp_party_level / self.wp_party_size  # if self.wp_party_size > 0 else 0
            level_difference = ap_avg_level - wp_avg_level

        # Assign base rewards based on the level difference
        if level_difference == 4:
            reward = 0.2
        elif level_difference == 3:
            reward = 0.4
        elif level_difference == 2:
            reward = 0.6
        elif level_difference == 1:
            reward = 0.8
        elif level_difference == 0:
            reward = 1
        elif level_difference == -1:
            reward = 1.5
        elif level_difference <= -2:
            reward = 2
        else:
            reward = 0  # Default case, if needed

        # Add a bonus for winning against a larger team in trainer battles
        if trainer_battle and self.ap_party_size <= self.wp_party_size:
            team_size_difference = abs(self.wp_party_size - self.ap_party_size)
            bonus = 0.5 * team_size_difference + 0.5
            reward += bonus

        self.battle_rewarded = True
        self.battle_reward_value = reward
        self.total_battle_reward += reward  # to keep record of total reward
        return reward

